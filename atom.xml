<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Mk Zang]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://zyq001.github.io/"/>
  <updated>2015-09-04T19:29:56.553Z</updated>
  <id>http://zyq001.github.io/</id>
  
  <author>
    <name><![CDATA[Mk Zang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linkedin/Gobblin架构与源码学习-从Kafa-Hdfs的case study开始]]></title>
    <link href="http://zyq001.github.io/2015/09/02/Linkedin-Gobblin%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BB%8EKafa-Hdfs%E7%9A%84case-study%E5%BC%80%E5%A7%8B/"/>
    <id>http://zyq001.github.io/2015/09/02/Linkedin-Gobblin架构与源码学习-从Kafa-Hdfs的case-study开始/</id>
    <published>2015-09-01T17:02:44.000Z</published>
    <updated>2015-09-04T19:29:56.553Z</updated>
    <content type="html"><![CDATA[<p>Gobblin是Linkedin内部用来整合各种数据源（关系型数据库，kafka，FTP/SFTP servers等等）通用ETL框架，于14年开源（<a href="https://github.com/linkedin/gobblin" target="_blank" rel="external">地址</a>）。用本人低俗的理解，画了一张很大的饼，各种数据都可以在这里“一站式”解决ETL整个过程（据说他们内部也是这么干的），专为大数据而生。</p>
<p>在某道公司实习的时候参与到一个实时统计系统的优化，之前日志数据从Kafka到Hdfs的落地用的是<a href="https://github.com/linkedin/camus" target="_blank" rel="external">Linkedin/camus</a>,但据说作者不想写了（也有人说写到太烂了，，），现在已经停止开发，借助Hdfs上由Avro改Parquet列式存储的机会，把camus替换成了Gobblin，花了一段时间了解Gobblin。  </p>
<p>论文的阅读理解和整体架构稍后再写吧，这次先借助官方Wiki的Kafka-Hdfs case study，从自己接触最多的部分开始介绍吧。  </p>
<p>作为一个通用框架，Gobblin的接口封装和概念抽象做的很好，作为一个ETL框架使用者，基本地，我们只需要实现我们自己的<strong>Source</strong>，<strong>Extractor</strong>，<strong>Conventer</strong>类，再加上一些源-目的地址之类的通过配置文件提交给Gobblin就行了，当然Gobblin已经为我们实现了很多类，可以直接拿来用，比如针对Kafka的KafkaExtractor,KafkaSource,KafkaAvroSource(肯定少不了为Avro定制的东西，，)。不过Gobblin强大的地方还在于，还可以让用户定制更多的东西，比如QualitlyChecker,Writer,Publisher等，还支持Compaction去重和小文件的merge。<br><a id="more"></a></p>
<h2 id="流程">流程</h2><hr>
<p>下面结合Gobblin文章中的流程图和源码中提供的Kafka-Hdfs的基础类，先分析下整体流程<br><img src="/images/linkedin-gobblin-scalable-ingestion-flow.png" alt="官方流图"></p>
<ol>
<li>配置文件指定我们的Source，Writer等类，和地址等，配置文件后缀名必须是.job或者.pull  </li>
<li>脚本启动，可以选Standalone和MR两种模式，通过参数或者环境变量指定一些工作目录详见[Wiki/Deployment]</li>
<li>gobblin-runtime包下的JobLauncher读取配置文件，将配置文件抽象成一种SourceState结构，</li>
<li><p>将SourceStare交给我们的KafaSource。Source类要做的跟数据源取得联系，比如初始化一些metadata元数据等，并生成WorkUnit（这个概念是为了迎合Yarn中Container的概念，并且可以指定配置一些策略如通过指定mapper数量修改对应关系，默认一个WorkUnit一个mapper，），然后把WorkUnit交给Extractor, gobblin-core包下自带的关于kafka的类见下图：<br><img src="/images/kafka.png" alt="kafka"><br>这里必须提一下KafkaWraper，这里封装了各种跟kafka打交道的api，不过截至目前都是用的old api，新api的接口函数以及有了，但是没有实现，调用会直接throw异常。</p>
</li>
<li><p>Extractor负责实现从数据源中读数据。</p>
</li>
<li>后面就是经过Converter和qualityChecker对数据做一些转换和校验，然后根据配置文件指定，选择writer写入本地文件或者HDFS，gobblin-core提供simple、Avro和fs三类writer，详见下图并针对Hdfs提供可根据时间切割文件的类。<br><img src="/images/writer.png" alt="writer"></li>
</ol>
<h2 id="接口">接口</h2><hr>
<ol>
<li><p><strong>Source</strong>类需要实现两个函数：  getWorkUnits,和getExtractor</p>
<p> <code>public List&lt;WorkUnit&gt; getWorkunits(SourceState state){}</code><br>根据解析出来的配置文件生成WorkUnit，这个在KafkaSource类中实现，但是KafkaSource还是抽象类，core包自带两个实现类，KafkaAvroSource和KafkaSimpleSource类</p>
<p> public Extractor<schema, genericrecord=""> getExtractor(WorkUnitState state) throws IOException {<br> return new KafkaAvroExtractor(state);<br>   }<br>KafkaAvroSource类就是产生一个Extractor，WorkUnit产生之后在被调度时会加上一些状态量比如<br> WorkUnitState workUnitState = new WorkUnitState(workUnit);<br> workUnitState.setId(taskId);<br> workUnitState.setProp(ConfigurationKeys.JOB_ID_KEY, jobId);<br> workUnitState.setProp(ConfigurationKeys.TASK_ID_KEY, taskId);<br> this.workUnitManager.addWorkUnit(workUnitState);<br>被调度的时候会根据WorkUnitState从getExtractor接口拿到一个Extractor句柄，来真正抽取数据。</schema,></p>
</li>
</ol>
<ol>
<li><p><strong>Extractor</strong>类需要实现的函数较多，最主要的还是readRecordImpl，不过core提供的KafkaExtractor还是抽象类，需要我们另外实现一个函数</p>
<p> D decodeRecord(MessageAndOffset messageAndOffset);<br>即解码kafka的MessageAndOffset对象</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gobblin是Linkedin内部用来整合各种数据源（关系型数据库，kafka，FTP/SFTP servers等等）通用ETL框架，于14年开源（<a href="https://github.com/linkedin/gobblin">地址</a>）。用本人低俗的理解，画了一张很大的饼，各种数据都可以在这里“一站式”解决ETL整个过程（据说他们内部也是这么干的），专为大数据而生。</p>
<p>在某道公司实习的时候参与到一个实时统计系统的优化，之前日志数据从Kafka到Hdfs的落地用的是<a href="https://github.com/linkedin/camus">Linkedin/camus</a>,但据说作者不想写了（也有人说写到太烂了，，），现在已经停止开发，借助Hdfs上由Avro改Parquet列式存储的机会，把camus替换成了Gobblin，花了一段时间了解Gobblin。  </p>
<p>论文的阅读理解和整体架构稍后再写吧，这次先借助官方Wiki的Kafka-Hdfs case study，从自己接触最多的部分开始介绍吧。  </p>
<p>作为一个通用框架，Gobblin的接口封装和概念抽象做的很好，作为一个ETL框架使用者，基本地，我们只需要实现我们自己的<strong>Source</strong>，<strong>Extractor</strong>，<strong>Conventer</strong>类，再加上一些源-目的地址之类的通过配置文件提交给Gobblin就行了，当然Gobblin已经为我们实现了很多类，可以直接拿来用，比如针对Kafka的KafkaExtractor,KafkaSource,KafkaAvroSource(肯定少不了为Avro定制的东西，，)。不过Gobblin强大的地方还在于，还可以让用户定制更多的东西，比如QualitlyChecker,Writer,Publisher等，还支持Compaction去重和小文件的merge。<br>]]>
    
    </summary>
    
      <category term="Gobblin" scheme="http://zyq001.github.io/tags/Gobblin/"/>
    
      <category term="Hdfs" scheme="http://zyq001.github.io/tags/Hdfs/"/>
    
      <category term="Kafka" scheme="http://zyq001.github.io/tags/Kafka/"/>
    
      <category term="OS项目" scheme="http://zyq001.github.io/categories/OS%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Gobblin" scheme="http://zyq001.github.io/categories/OS%E9%A1%B9%E7%9B%AE/Gobblin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git常见问题备忘]]></title>
    <link href="http://zyq001.github.io/2015/08/30/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E5%BF%98/"/>
    <id>http://zyq001.github.io/2015/08/30/git常见问题备忘/</id>
    <published>2015-08-30T07:15:46.000Z</published>
    <updated>2015-09-03T15:39:06.682Z</updated>
    <content type="html"><![CDATA[<h3 id="1,github_changes_not_staged_for_commit">1,github changes not staged for commit</h3><p>   Git在未进行commit操作之前，存在三种状态：Untracked files，<br>   Changes not staged for commit及Changes to be committed，每种状态之间可以随意进行互相转换。</p>
<p>   -Changes not staged for </p>
<p>   commit”状态，表明文件已经修改，但是还没有放入暂存区域，也就是没生成快照。<br>   如果现在进行commit操作，只是将修改之前的文件快照提交到了git目录，<br>   只有暂存区域的文件（即：文件状态为“Changes to be committed”）才会被提交。<br>   正如提示，通过“git add README.txt”命令将已修改文件更新到暂存区域中，<br>   如果想撤销修改，可以使用“git checkout – README.txt”命令。<br>   <a id="more"></a><br>   如果通过git add . 或者 git add * 或者git add 文件名都依然处于not staged状态，那么需要考虑项目中是否有submodule（子模块），<br>   如果有，需要现在submodule中 add &amp; commit，再在主项目中git add才能把最新修改提交到本地版本库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1,github_changes_not_staged_for_commit">1,github changes not staged for commit</h3><p>   Git在未进行commit操作之前，存在三种状态：Untracked files，<br>   Changes not staged for commit及Changes to be committed，每种状态之间可以随意进行互相转换。</p>
<p>   -Changes not staged for </p>
<p>   commit”状态，表明文件已经修改，但是还没有放入暂存区域，也就是没生成快照。<br>   如果现在进行commit操作，只是将修改之前的文件快照提交到了git目录，<br>   只有暂存区域的文件（即：文件状态为“Changes to be committed”）才会被提交。<br>   正如提示，通过“git add README.txt”命令将已修改文件更新到暂存区域中，<br>   如果想撤销修改，可以使用“git checkout – README.txt”命令。<br>]]>
    
    </summary>
    
      <category term="changes not staged" scheme="http://zyq001.github.io/tags/changes-not-staged/"/>
    
      <category term="git" scheme="http://zyq001.github.io/tags/git/"/>
    
      <category term="github" scheme="http://zyq001.github.io/tags/github/"/>
    
      <category term="问题" scheme="http://zyq001.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="研发管理" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
      <category term="git" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[列式Parquet与行式Avro，对比Benchmarks性能分析]]></title>
    <link href="http://zyq001.github.io/2015/08/20/%E5%88%97%E5%BC%8FApache%20Parquet%E4%B8%8E%E8%A1%8C%E5%BC%8FAvro%EF%BC%8C%E5%AF%B9%E6%AF%94Benchmarks%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://zyq001.github.io/2015/08/20/列式Apache Parquet与行式Avro，对比Benchmarks性能分析/</id>
    <published>2015-08-19T16:40:09.000Z</published>
    <updated>2015-09-04T19:14:09.971Z</updated>
    <content type="html"><![CDATA[<h2 id="关于Parquet">关于Parquet</h2><p>  Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目，细节请参考[[这里|<a href="http://parquet.apache.org/documentation/latest/]]。" target="_blank" rel="external">http://parquet.apache.org/documentation/latest/]]。</a></p>
<h3 id="列式存储">列式存储</h3><a id="more"></a>
<p>  列式存储和行式存储相比有哪些优势呢？</p>
<ul>
<li>可以跳过不符合条件的数据，只读取需要的数据，降低IO数据量。</li>
<li>压缩编码可以降低磁盘存储空间。由于同一列的数据类型是一样的，可以使用更高效的压缩编码（例如Run Length Encoding和Delta Encoding）进一步节约存储空间。</li>
<li>只读取需要的列，支持向量运算，能够获取更好的扫描性能。</li>
</ul>
<h3 id="适配多种计算框架">适配多种计算框架</h3><p>Parquet是语言无关的，而且不与任何一种数据处理框架绑定在一起，适配多种语言和组件，能够与Parquet配合的组件有：</p>
<ul>
<li>查询引擎: Hive, Impala, Pig, Presto, Drill, Tajo, HAWQ, IBM Big SQL</li>
</ul>
<ul>
<li>计算框架: MapReduce, Spark, Cascading, Crunch, Scalding, Kite</li>
</ul>
<ul>
<li>数据模型: Avro, Thrift, Protocol Buffers, POJOs</li>
</ul>
<h3 id="性能">性能</h3><p>Parquet就是基于Google的<strong>Dremel</strong>系统的数据模型和算法实现的。核心思想是使用“record shredding and assembly algorithm”来表示复杂的嵌套数据类型，同时辅以按列的高效压缩和编码技术，实现降低存储空间，提高IO效率，降低上层应用延迟。</p>
<p>Parquet列式存储带来的性能上的提高在业内已经得到了充分的认可，特别是当你们的表非常宽（column非常多）的时候，Parquet无论在资源利用率还是性能上都优势明显。具体的性能指标详见参考文档。</p>
<p>Spark已经将Parquet设为默认的文件存储格式，Cloudera投入了很多工程师到Impala+Parquet相关开发中，Hive/Pig都原生支持Parquet。Parquet现在为Twitter至少节省了1/3的存储空间，同时节省了大量的表</p>
<p>扫描和反序列化的时间。这两方面直接反应就是节约成本和提高性能（详见[[YaqiangZang#benchmark|benchmark]]）。</p>
<h2 id="benchmark">benchmark</h2><p>以邮箱的展示日志为例，比较了Avro和Parquet两种存储格式的性能：camus-2015/05/24的日志，5,361,809条记录，ns005，hadoop2.4，Spark1.3.1。结果见下图：</p>
<p><img src="/images/parquetBenchMarkRest.png" alt="测试结果"> </p>
<p>备注：1. 测试代码详见github - <a href="https://github.com/zyq001/AvroParquetBenchMark" target="_blank" rel="external">AvroParquetBenchMark</a>   2. 读取Avro是新老API性能差距较大，目前还未找到原因。</p>
<h2 id="与Avro">与Avro</h2><p>之前新统计系统（Quipu）的日志都是用Avro做序列化和存储，鉴于Parquet的优势和对Avro的兼容，将HDFS上的存储格式改为Paruqet，并且只需做很小的改动就用原读取Avro的API读取Parquet，单列查询效率可</p>
<p>以提高近一个数量级。</p>
<h2 id="Schema">Schema</h2><p>Parquet文件尾部存储了文件的元数据信息和统计信息，自描述的，方便解析。仍沿用原Avro的schema。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="关于Parquet">关于Parquet</h2><p>  Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目，细节请参考[[这里|<a href="http://parquet.apache.org/documentation/latest/]]。">http://parquet.apache.org/documentation/latest/]]。</a></p>
<h3 id="列式存储">列式存储</h3>]]>
    
    </summary>
    
      <category term="HDFS" scheme="http://zyq001.github.io/tags/HDFS/"/>
    
      <category term="Spark" scheme="http://zyq001.github.io/tags/Spark/"/>
    
      <category term="parquet" scheme="http://zyq001.github.io/tags/parquet/"/>
    
      <category term="列式存储" scheme="http://zyq001.github.io/tags/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="Hadoop" scheme="http://zyq001.github.io/categories/Hadoop/"/>
    
      <category term="HDFS" scheme="http://zyq001.github.io/categories/Hadoop/HDFS/"/>
    
      <category term="存储格式" scheme="http://zyq001.github.io/categories/Hadoop/HDFS/%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
    
      <category term="Parquet" scheme="http://zyq001.github.io/categories/Hadoop/HDFS/%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/Parquet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[angularJS学习笔记]]></title>
    <link href="http://zyq001.github.io/2015/07/10/angularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyq001.github.io/2015/07/10/angularJS学习笔记/</id>
    <published>2015-07-10T02:52:37.000Z</published>
    <updated>2015-09-03T03:57:35.511Z</updated>
    <content type="html"><![CDATA[<p>AngularJS 通过 <strong>ng-directives</strong> 扩展了 HTML。</p>
<ul>
<li><strong>ng-app</strong> 指令定义一个 AngularJS 应用程序。  </li>
</ul>
<ul>
<li><strong>ng-model</strong> 指令把元素值（比如输入域的值）绑定到应用程序。  </li>
</ul>
<ul>
<li><strong>ng-bind</strong> 指令把应用程序数据绑定到 HTML 视图。  </li>
</ul>
<p>什么是 AngularJS？</p>
<p>“AngularJS 是专门为<strong>应用程序</strong>设计的 HTML。”<br>AngularJS 使得开发现代的<strong>单一页面应用程序</strong>（SPAs：Single Page Applications）变得更加容易。<br>AngularJS 把应用程序<strong>数据绑定到 HTML 元素</strong>。<br>AngularJS 可以<strong>克隆和重复</strong> HTML 元素。<br>AngularJS 可以<strong>隐藏和显示</strong> HTML 元素。<br>AngularJS 可以在 HTML 元素”背后”<strong>添加代码</strong>。<br>AngularJS 支持<strong>输入验证</strong>。<br><a id="more"></a></p>
<h3 id="ng-app_指令">ng-app 指令</h3><hr>
<p>ng-app 指令定义了 AngularJS 应用程序的 <strong>根元素</strong>。<br>ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。    </p>
<h3 id="ng-init_指令">ng-init 指令</h3><hr>
<p>ng-init 指令为 AngularJS 应用程序定义了 <strong>初始值</strong>。<br>通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。<br>稍后您将学习更多有关控制器和模块的知识。  </p>
<h3 id="ng-model_指令">ng-model 指令</h3><hr>
<p>ng-model 指令 绑定 HTML 元素 到应用<strong>程序数据</strong>。<br>ng-model 指令也可以：</p>
<ul>
<li><p>为应用程序数据提供类型<strong>验证</strong>（number、email、required）。</p>
</li>
<li><p>为应用程序数据提供状态（invalid、dirty、touched、error）。</p>
</li>
<li><p>为 HTML 元素提供 CSS 类。</p>
</li>
<li><p>绑定 HTML 元素到 HTML 表单。  </p>
</li>
</ul>
<h3 id="ng-repeat_指令">ng-repeat 指令</h3><hr>
<p>ng-repeat 指令对于集合中（数组中）的每个项会 <strong>克隆一次</strong> HTML 元素。  </p>
<h2 id="AngularJS_控制器">AngularJS 控制器</h2><hr>
<p>AngularJS 应用程序被控制器控制。<br><strong>ng-controller</strong> 指令定义了应用程序控制器。<br>控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。<br>控制器的 <code>$scope</code> 是控制器所指向的应用程序 HTML 元素。  </p>
<p>实例讲解：<br>AngularJS 应用程序由 ng-app 定义。应用程序在 <div> 内运行。<br>ng-controller 指令把控制器命名为 object。<br>函数 personController 是一个标准的 JavaScript 对象的构造函数。<br>控制器对象有一个属性：<code>$scope.person</code>。<br>person 对象有两个属性：firstName 和 lastName。<br>ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。  </div></p>
<p>上面的实例演示了一个带有 lastName 和 firstName 这两个属性的控制器对象。<br>控制器也可以把函数作为对象属性：  </p>
<h3 id="控制器方法">控制器方法</h3><p>控制器也可以带有方法：  </p>
<h3 id="AngularJS_过滤器">AngularJS 过滤器</h3><p>过滤器可以使用一个管道字符（|）添加到表达式和指令中。<br>AngularJS 过滤器  </p>
<p>AngularJS 过滤器可用于<strong>转换数据</strong>：<br>过滤器  &#8195;    &#8195;描述<br>currency    格式化数字为货币格式。<br>filter    &#8195;从数组项中选择一个子集。<br>lowercase    格式化字符串为小写。<br>orderBy    &#8194;根据某个表达式排列数组。<br>uppercase    格式化字符串为大写。  </p>
<ul>
<li>向表达式添加过滤器</li>
</ul>
<p>过滤器可以通过一个管道字符（|）和一个过滤器添加到表达式中。<br>（下面的两个实例，我们将使用前面章节中提到的 person 控制器）<br>uppercase 过滤器格式化字符串为大写：</p>
<p><strong>过滤输入</strong></p>
<p>输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。<br>filter 过滤器从数组中选择一个子集：  </p>
<h3 id="AngularJS_XMLHttpRequest">AngularJS XMLHttpRequest</h3><p>$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。<br>AngularJS $http  </p>
<p>AngularJS<code>$http</code> 是一个用于读取web服务器上数据的服务。<br><code>$http.get(url)</code>是用于读取服务器数据的函数。  </p>
<h2 id="AngularJS_SQL">AngularJS SQL</h2><hr>
<p>在前面章节中的代码也可以用于读取数据库中的数据<br>使用 PHP 从 MySQL 中获取数据</p>
<p>PHP 读取 MySQL 数据代码  </p>
<h3 id="AngularJS_HTML_DOM">AngularJS HTML DOM</h3><p>AngularJS 有自己的 HTML 属性指令。<br><strong>ng-disabled 指令</strong></p>
<p>ng-disabled 指令直接绑定应用程序数据到 HTML 的 disabled 属性。</p>
<p><strong>ng-show 指令</strong></p>
<p>ng-show 指令<strong>隐藏或显示</strong>一个 HTML 元素。</p>
<h2 id="AngularJS_HTML_事件">AngularJS HTML 事件</h2><hr>
<p>AngularJS 有自己的 HTML 事件指令。<br><strong>ng-click</strong> 指令</p>
<p>ng-click 指令定义了一个 AngularJS <strong>单击</strong>事件。</p>
<ul>
<li>隐藏 HTML 元素</li>
</ul>
<p><strong>ng-hide</strong>指令用于设置应用的一部分 不可见 。<br><code>ng-hide=&quot;true&quot;</code>让 HTML 元素 不可见。<br><code>ng-hide=&quot;false&quot;</code> 让元素可见。</p>
<ul>
<li>显示 HTML 元素</li>
</ul>
<p><strong>ng-show</strong> 指令可用于设置应用中的一部分可见 。<br><code>ng-show=&quot;false&quot;</code> 可以设置 HTML 元素 不可见。<br><code>ng-show=&quot;true&quot;</code> 可以以设置 HTML 元素可见。<br>以下实例使用了 ng-show 指令:</p>
<h2 id="AngularJS_模块">AngularJS 模块</h2><hr>
<p>模块定义了您的应用程序。<br>所有的控制器都应该属于一个模块。<br>模块保持全局命名空间中的整洁。<br>AngularJS 模块实例  </p>
<p>在本实例中，”myApp.js” 包含了一个应用程序模块定义，”myCtrl.js” 包含了一个控制器：  </p>
<p>使用一个由 模块 替代的控制器：  </p>
<p>您的应用程序至少应该有一个模块文件，一个控制器文件。<br>首先，创建模块文件 “myApp.js”：  </p>
<p>然后，创建控制器文件。本实例中是 “myCtrl.js”：  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>AngularJS 通过 <strong>ng-directives</strong> 扩展了 HTML。</p>
<ul>
<li><strong>ng-app</strong> 指令定义一个 AngularJS 应用程序。  </li>
</ul>
<ul>
<li><strong>ng-model</strong> 指令把元素值（比如输入域的值）绑定到应用程序。  </li>
</ul>
<ul>
<li><strong>ng-bind</strong> 指令把应用程序数据绑定到 HTML 视图。  </li>
</ul>
<p>什么是 AngularJS？</p>
<p>“AngularJS 是专门为<strong>应用程序</strong>设计的 HTML。”<br>AngularJS 使得开发现代的<strong>单一页面应用程序</strong>（SPAs：Single Page Applications）变得更加容易。<br>AngularJS 把应用程序<strong>数据绑定到 HTML 元素</strong>。<br>AngularJS 可以<strong>克隆和重复</strong> HTML 元素。<br>AngularJS 可以<strong>隐藏和显示</strong> HTML 元素。<br>AngularJS 可以在 HTML 元素”背后”<strong>添加代码</strong>。<br>AngularJS 支持<strong>输入验证</strong>。<br>]]>
    
    </summary>
    
      <category term="Js" scheme="http://zyq001.github.io/tags/Js/"/>
    
      <category term="angular" scheme="http://zyq001.github.io/tags/angular/"/>
    
      <category term="Js" scheme="http://zyq001.github.io/categories/Js/"/>
    
      <category term="angular" scheme="http://zyq001.github.io/categories/Js/angular/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coding 小技巧]]></title>
    <link href="http://zyq001.github.io/2015/07/04/Java-Coding-%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://zyq001.github.io/2015/07/04/Java-Coding-小技巧/</id>
    <published>2015-07-04T15:31:49.000Z</published>
    <updated>2015-09-04T16:00:15.290Z</updated>
    <content type="html"><![CDATA[<ol>
<li>如何打印数组不用for–println without foreach  </li>
</ol>
<p>就算debug用的再6，写代码中不可避免地要打印一些东西，高级语言横行的时代，Java数组打印居然还要自己foreach，不过还好各种容器类如List重写了toString函数，可以直接打印，那么问题就简单了，把数组转换成List。而且查阅源码，发现</p>
<ul>
<li><code>Arrays.asList(T... a)</code>其实是new了一个ArrayList，而且直接把数组的指针赋值过去的，没有多余地进行ArrayCopy。不过既然是模板，那么基本类型的数组是没法用的，，  </li>
<li><code>Arrays.toString(各种类型包括Object[])</code>后来发现这个，这个重载了好多，不仅支持Object数组，还支持各种基本类型数组，那就直接拿来用吧！<br><strong>总结:</strong><br>如果是基本类型，如int[] arr,这样打：<code>System.out.println(Arrays.toString(arr));</code><br>如果是String[]或者其他Object[] arr,这样打：<code>System.out.println(Arrays.asList(arr));</code> </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>如何打印数组不用for–println without foreach  </li>
</ol>
<p>就算debug用的再6，写代码中不可避免地要打印一些东西，高级语言横行的时代，Java数组打印居然还要自己foreach，不过还好各种容器类如List重写了t]]>
    </summary>
    
      <category term="tips" scheme="http://zyq001.github.io/tags/tips/"/>
    
      <category term="tips" scheme="http://zyq001.github.io/categories/tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Maven】【gradle】java.io.IOException: No locks available常见解决方案]]></title>
    <link href="http://zyq001.github.io/2015/05/03/%E3%80%90Maven%E3%80%91%E3%80%90gradle%E3%80%91java-io-IOException-No-locks-available%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://zyq001.github.io/2015/05/03/【Maven】【gradle】java-io-IOException-No-locks-available常见解决方案/</id>
    <published>2015-05-03T01:55:02.000Z</published>
    <updated>2015-09-03T15:13:04.268Z</updated>
    <content type="html"><![CDATA[<p>thumbnail: /images/maven_tb.png<br>banner: /images/maven_bner.png</p>
<pre><code>Java<span class="class">.io</span><span class="class">.IOException</span>: No locks available
    at sun<span class="class">.nio</span><span class="class">.ch</span><span class="class">.FileChannelImpl</span><span class="class">.lock0</span>(Native Method)
    at sun<span class="class">.nio</span><span class="class">.ch</span><span class="class">.FileChannelImpl</span><span class="class">.lock</span>(FileChannelImpl<span class="class">.java</span>:<span class="number">784</span>)
    at java<span class="class">.nio</span><span class="class">.channels</span><span class="class">.FileChannel</span><span class="class">.lock</span>(FileChannel<span class="class">.java</span>:<span class="number">865</span>)
</code></pre><p>能够下载依赖的jar包，但是每下载一次都会跑出<strong>No locks available</strong>异常，而且每个jar下载都需要等待很久。</p>
<p>最后通过 df   -T   -h 命令才发现当前目录挂载的是NFS。<br><a id="more"></a><br>传送门：NFS介绍<br><a href="http://book.51cto.com/art/200808/85167.htm" target="_blank" rel="external">http://book.51cto.com/art/200808/85167.htm</a><br><a href="http://fedora.linuxsir.org/main/?q=node/41" target="_blank" rel="external">http://fedora.linuxsir.org/main/?q=node/41</a></p>
<p>这一般是因为 /home/* , /global,以及常用的/diskN是独立的，为了方便在任何一台机器上都可以访问/home和/global,所以这两个目录做的非本地的（也就是NFS）</p>
<p>Maven 和 gradle的默认本地仓库是home下的 如/home/userName/.gradle（或者.m2）</p>
<p>网上搜到的解决方案<br>1、启用NFS filesystem lock服务<br>2、换个本地的filesystem<br><strong>实际上 </strong>   </p>
<ol>
<li>公司的开发机，一般用户是没有roo权限的，所以方法1不能实现    </li>
<li>关于2,  以下是具体操作：<br>&#8195;&#8195; <strong>Maven：</strong><br>&#8195;&#8195;<strong>settings.xml</strong>文件中的： <code>&lt;localRepository&gt;/disk1/username/.m2/&lt;/localRepository&gt;</code>  设置到一个非NFS的Disk(本地, 如disk1，disk2，之类的)上。基本的maven 安装和配置网上有很多。  </li>
</ol>
<p>&#8195;&#8195;<strong>Gradle：</strong><br>&#8195;&#8195;1. 本地安装的Gradle 则修改   gradle目录下的 bin/gradle（Windows是bin/gradle.bat文件）<br><code>GRADLE_OPTS=-Dgradle.user.home=/disk1/userName/gradle#</code>添加这一行~<br>&#8195;&#8195;2. 项目自带的gradlew（如某些采用gradle构建的开源项目 LinkedIn Gobblin）则修改gradlew文件也是添加那一行</p>
<p>参考：<br><a href="http://blog.csdn.net/liu251/article/details/7431696" target="_blank" rel="external">http://blog.csdn.net/liu251/article/details/7431696</a><br><a href="http://www.vicviz.com/gradle-in-action-bi-ji/" target="_blank" rel="external">http://www.vicviz.com/gradle-in-action-bi-ji/</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>thumbnail: /images/maven_tb.png<br>banner: /images/maven_bner.png</p>
<pre><code>Java<span class="class">.io</span><span class="class">.IOException</span>: No locks available
    at sun<span class="class">.nio</span><span class="class">.ch</span><span class="class">.FileChannelImpl</span><span class="class">.lock0</span>(Native Method)
    at sun<span class="class">.nio</span><span class="class">.ch</span><span class="class">.FileChannelImpl</span><span class="class">.lock</span>(FileChannelImpl<span class="class">.java</span>:<span class="number">784</span>)
    at java<span class="class">.nio</span><span class="class">.channels</span><span class="class">.FileChannel</span><span class="class">.lock</span>(FileChannel<span class="class">.java</span>:<span class="number">865</span>)
</code></pre><p>能够下载依赖的jar包，但是每下载一次都会跑出<strong>No locks available</strong>异常，而且每个jar下载都需要等待很久。</p>
<p>最后通过 df   -T   -h 命令才发现当前目录挂载的是NFS。<br>]]>
    
    </summary>
    
      <category term="Maven" scheme="http://zyq001.github.io/tags/Maven/"/>
    
      <category term="gradle" scheme="http://zyq001.github.io/tags/gradle/"/>
    
      <category term="研发管理" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
      <category term="maven/gradle" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/maven-gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java, 基础（面试题）总结（分享-交流）]]></title>
    <link href="http://zyq001.github.io/2015/04/29/Java-%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89%E6%80%BB%E7%BB%93%EF%BC%88%E5%88%86%E4%BA%AB-%E4%BA%A4%E6%B5%81%EF%BC%89/"/>
    <id>http://zyq001.github.io/2015/04/29/Java-基础（面试题）总结（分享-交流）/</id>
    <published>2015-04-28T18:02:42.000Z</published>
    <updated>2015-09-03T15:31:59.885Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_Finally，final，finalize">1. Finally，final，finalize</h3><ul>
<li><p>Finally：<br>  释放资源（内存之外的，打开的文件、连接、屏幕上的图形，，）</p>
<ul>
<li>总会执行</li>
<li>非后台线程结束，后台线程被强关，不会执行finally</li>
<li>当try和catch中有return时，finally在return之后执行，但是返回值不会改变（finally中不会改变已保存的返回结果）</li>
<li>finally中最好不要包含return，否则程序会从finally中退出，返回值不是try或catch中保存的返回值。</li>
</ul>
</li>
<li><p>final：<br>  基本数据类型：不可更改<br>  类：不可继承<br>  对象：引用不可变，对象内容可变</p>
</li>
<li><p>finalze：<br>回收前调用，不适合用来清理或释放资源。对象免死最后机会！保证会被调用，但不保证会执行完(在低优先级线程中执行)</p>
<a id="more"></a>
</li>
</ul>
<h3 id="2-_数据在各个网络层之间是怎么传输的？">2. 数据在各个网络层之间是怎么传输的？</h3><ul>
<li>数据在各层之间的单位都是不一样的，</li>
<li>在物理层数据的单位称为比特（bit）；在数据链路层，数据的单位称为帧（frame）；</li>
<li>在网络层，数据的单位称为数据包（packet）；传输层，数据的单位称为数据段（segment）。 </li>
</ul>
<h3 id="3-_Hashtable、HashMap">3. Hashtable、HashMap</h3><ul>
<li><p>Hashtable 与 HashMap类似,但是主要有7点不同。</p>
<ol>
<li>HashTable的方法是同步的，HashMap未经同步，如Vector和ArrayList一样。</li>
<li>HashTable不允许null，key和value都不可以,HashMap允许null值，key和value都可以。HashMap允许 key值只能由一个null</li>
<li>HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。</li>
<li>遍历的时候，HashTable使用Enumeration，HashMap使用Iterator。</li>
<li>HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li>
<li>哈希值的使用不同，HashTable直接使用对象的hashCode。</li>
<li>Hashtable继承自Dictionary类，实现了Map接口。而HashMap是继承自AbstractMap，实现了Map接口。</li>
</ol>
</li>
<li><p><strong>HashMap:</strong><br>一个数组，hash（h）决定位置，<br> 冲突使用链表法：单向–Entry对象（保存final key，value，next指针，hash值），遍历比较hash值<br> Collections.synchronizedMap(hashmap)来构造一个线程安全的map，与Hashtable几乎一样<br> 扩容：先插入再判断是否扩容</p>
</li>
<li><p><strong>Hashtable：</strong> 直接使用对象hash值，对跟线程安全相关的方法和步骤加Syncrolized</p>
</li>
<li><p><strong>LinkedHashMap：</strong><br>继承HashMap， 重写Entry类，before，after两个指针，保存插入顺序或者访问顺序（可指定）</p>
</li>
<li><strong>HashSet：</strong><br>持有一个HashMap</li>
</ul>
<ul>
<li><strong>ConcurrentHashMap:</strong>  <ul>
<li>两个数组Segment[] 和HashEntry[]    </li>
<li><strong>Segment：</strong> extends ReentrantLock, 一种可重入锁，持有一个数组HashEntry[]，可以通过concurrencylevel指定Segment数组长度  </li>
<li><strong>HashEntry：</strong> hash，key，value，next</li>
<li><strong>读不需要锁</strong>，读到空时加锁重读</li>
<li><strong>扩容：</strong>支队某个Segment的HashEntry[]扩容，先判断是否扩容再插入</li>
<li><strong>size（）</strong>：先尝试两次锁，判断modCount是否变化再决定是否加锁。 </li>
</ul>
</li>
<li><strong>CopyOnWriteArrayList:</strong> 适合多读少写，只保证最终一致性，不保证实时一致性<ul>
<li>加锁–&gt;拷贝数据–&gt;改、写–&gt;赋值回去–&gt;解锁</li>
<li>用的ReentrantLock，读无需锁，可能读到旧数据。    </li>
</ul>
</li>
<li><strong>TreeMap：</strong>红黑树，可自定义顺序</li>
<li><strong>TessSet：</strong>TreeMap</li>
</ul>
<h3 id="4-_GET，POST区别？">4. GET，POST区别？</h3><ul>
<li><p><strong>基础知识：</strong>  Http的请求格式如下。<br><strong><request line\=""></request></strong>   主要包含三个信息：<br>1、请求的类型（GET或POST），2、要访问的资源（如res\img\a.jif），3、Http版本（http/1.1）<br><strong><header\></header\></strong>  用来说明服务器要使用的附加信息<br><strong><blank line\=""></blank></strong>  这是Http的规定，必须空一行<br><strong>[<request-body\>]</request-body\></strong>  请求的内容数据   </p>
</li>
<li><p><strong>区别：</strong><br>1、Get是从服务器端获取数据，Post则是向服务器端发送数据。<br>2、在客户端，Get方式通过URL提交数据，在URL地址栏可以看到请求消息，该消息被编码过；Post数据则是放在Html header内提交。<br>3、对于Get方式，服务器端用Request.QueryString获取变量的值；对用Post方式，服务器端用Request.Form获取提交的数据值。<br>4、Get方式提交的数据最多1024字节，而Post则没有限制。<br>5、Get方式提交的参数及参数值会在地址栏显示，不安全，而Post不会，比较安全。</p>
</li>
</ul>
<h3 id="5-_网游服务器用TCP还是UDP">5. 网游服务器用TCP还是UDP</h3><ul>
<li>UDP：多用，一个socket，加自己的可靠协议，延迟要求高</li>
<li>TCP：承载链接数多，500以上有压力，魔兽世界用TCP，1000延迟照样玩</li>
<li>HTTP/HTTPS：由客户端间歇性的发起无状态的查询，并且偶尔发生延迟是可以容忍</li>
</ul>
<h3 id="6-_关于JAVA内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。">6. 关于JAVA内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</h3><ul>
<li>由于JAVA中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，  </li>
</ul>
<ul>
<li>一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份。</li>
</ul>
<h3 id="7-_红黑树的好处、AVL_树">7.  红黑树的好处、AVL 树</h3><ul>
<li><p><strong>红黑树性质：</strong>  </p>
<ul>
<li>根节点是黑色的；  </li>
<li>非黑即红；  </li>
<li>叶节点（空节点）是黑色的；  </li>
<li>父节点是红色的，则其孩子节点必须是黑色的；  </li>
<li>从某一个节点到叶节点的所有路径，其黑色节点数目相同。 </li>
</ul>
</li>
<li><p><strong>红黑树好处：</strong>  </p>
<ul>
<li>红黑树是许多“平衡的”查找树中的一种，它能保证在最坏情况 下，基本的动态集合操作时间为 O(lgn)。   </li>
<li>红黑树并不追求完全平衡，它只要求部分的达到平衡要求，降低 了对旋转的要求，从而提高了性能。由于它的设计，任何不平衡都会在三次旋转之内解决。</li>
<li>红黑树的算法时间复杂度和 AVL相同， 但统计性能比 AVL 树更高。 </li>
<li>AVL 树明显比红黑树逻辑简单的多，但应用得少，应该是增删性能  差一点，增删时需要旋转的次数可能比较多。</li>
</ul>
</li>
</ul>
<h3 id="8-_数组和链表，遍历效率哪个高，为什么（cpu缓存与内存）">8. 数组和链表，遍历效率哪个高，为什么（cpu缓存与内存）</h3><ul>
<li><strong>数组的效率高</strong>，因为数组是连续存储的，即内存地址是连续的，所以在读取数组时，会将连续的内存地址的数据放入缓存中，所以读取数组时相当于是从缓存读取。而链表遍历都是从内存读取，缓存的读取速度要比内存块 100 倍左右。</li>
</ul>
<h3 id="9-_进程间通信,_怎么共享内存">9. 进程间通信, 怎么共享内存</h3><ul>
<li><strong>匿名管道：</strong>单向，只能用于具有亲缘关系的进程间通信，如父 子进程、兄弟进程等，缓冲区大小有限制。 </li>
<li><strong>命名管道：</strong>单向，可以用在任意的两个不同的进程间通信。</li>
<li><strong>信号量：</strong>主要用于同步。</li>
<li><strong>共享内存：</strong>最快的 IPC 机制，一般和信号量一起使用。一个进程创建，其他进程通过映射的形式，将共享内存加入到自己的内存空间中。数据结构：shmid_ds，函数 shmget:可以创建或 打开一块共享内存。 </li>
<li><strong>消息队列：</strong>是消息的链接表，有足够权限的进程可以向队列中 添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了管道只能承载无格式字节流以及缓冲区大小受 限等缺点。 </li>
<li><strong>Socket：</strong>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。</li>
</ul>
<h3 id="10-_Fork_进程时，继承那些：">10. Fork 进程时，继承那些：</h3><ul>
<li><strong>继承</strong>：进程的资格、堆栈、环境、内存、打开文件的描述符、执行时关闭标志、信号控制设定、nice 值、进程调度类别、进程 组号、当前工作目录、根目录、资源限制、控制终端。</li>
<li><strong>独有</strong>：进程号、不同的父进程号、自己的文件描述符和目 录流的拷贝、子进程不继承父进程的进程，正文，数据和其他锁定内存、在 tms 结构中的系统时间、资源使用设定为 0、阻塞信号集初始化为空集、不继承由 timer_create 函数创建的计时器、不继承异步输入和输出。</li>
</ul>
<h3 id="11-_1000_个超大的文件，可能每一个都超过内存，怎么对他们进_行排序和消除冲项，1_个超大怎么排序和消除重项。">11. 1000 个超大的文件，可能每一个都超过内存，怎么对他们进 行排序和消除冲项，1 个超大怎么排序和消除重项。</h3><ul>
<li>读文件，计算hash（%10000），分成更小的文件，重复项肯定在一个文件里，归并的时候去重</li>
</ul>
<h3 id="12-_2_个数组，一个超大数组（10w_记录），一个小一点，几千条，_问怎么找交集。两个数组元素无重复">12. 2 个数组，一个超大数组（10w 记录），一个小一点，几千条， 问怎么找交集。两个数组元素无重复</h3><ul>
<li><strong>bitmap：</strong>bit数组，已bit代表一个数，1表示有，遍历大数组构造bit数组；遍历小数组，看对应位置是否为1</li>
</ul>
<h3 id="13-_StackOverFlow和OutOfMemory分别在什么情况下出现">13. StackOverFlow和OutOfMemory分别在什么情况下出现</h3><ul>
<li><p><strong>StackOverFlow：</strong>一般情况下stack的默认值为128k~256k, -Xss1024m<br>请求栈深度大于允许最大深度，如：深度循环递归</p>
<ul>
<li><strong>OutOfMemory：</strong><br>多线程环境下，能够创建的线程最大内存=物理内存-最大堆内存-最大方法区内存，java虚拟机栈就会因为内存太小无法创建线程而产生OutOfMemoryError<br>大的对象或数组，堆地方不够用<br>运行时常量池（方法区）因无法再添加常量而产生OutOfMemoryError<br>直接内存用光，堆与直接内存&gt;物理内存<br>虚拟机栈动态扩展时无法获得足够内存</li>
</ul>
</li>
</ul>
<h3 id="14-_java虚拟机模型">14. java虚拟机模型</h3><ul>
<li><strong>虚拟机栈：</strong> 方法内存模型，一个方法一个栈帧，包括：局部变量表，操作数栈，动态链接，方法出口，请求栈深度大于允许报StackOverFlow，动态扩展无法申请足够内存，包OOM。-xss设栈容量默认256k？ </li>
</ul>
<ul>
<li><strong>局部变量表：</strong> 所属对象引用，方法参数，局部变量（基本类型，引用）<br>本地方法栈：与虚拟机栈相识，面向本地native方法，hotspot中与虚拟机栈合二为一  </li>
</ul>
<ul>
<li><strong>堆：</strong> 对象实例，数组，类加载完成便可确定对象大小，OOM  </li>
</ul>
<ul>
<li><strong>方法区：</strong> 也有人叫永久代（Permanent Generation）类信息，常量，静态变量等在加载完成后放入方法区，即时编译器编译后的代码。  </li>
</ul>
<ul>
<li><strong>运行常量池</strong>：class文件中的常量池，编译生成的字面量，符号引用（new对象时：先检查此类的符号引用是否加载、解析、初始化过，若否，先加载）；动态性：String.intern</li>
</ul>
<h3 id="15-_虚拟机垃圾回收">15. 虚拟机垃圾回收</h3><ul>
<li><strong>可达性分析:</strong> 从GCroots向下搜索，判断是否有引用可达。  </li>
<li><p><strong>GCroots:</strong><br> 虚拟机栈（本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象  </p>
</li>
<li><p><strong>强引用：</strong>永远不会回收被引用的对象。<br><strong>软引用SoftRef：</strong>有用但非必需的对象，发生内存溢出异常前将对象列进回收范围中进行第二次回收，如果此次回收还没有足够内存才会抛异常<br><strong>弱引用WeakRef：</strong>非必需对象，只能生存到下一次垃圾回收之前，无论内存是否够，都会回收<br><strong>虚引用PhantomRef：</strong>完全不对生存时间构成影响，也无法通过虚引用来取得一个对象实例</p>
</li>
<li><p><strong>标记整理算法:</strong> 所有存活的对象都向一端移动，然后清理边界以外的内存<br><strong>分代收集：</strong>当前多采用，<br><strong>复制算法:</strong>老年代做担保，新生代分三块一个Eden80％ 两个survivor都是10％</p>
</li>
<li><p><strong>java堆</strong>分成：新生代Eden，老年代(Survivor，两个 from to)<br>   <strong>新生代：</strong>复制算法，<br>   <strong>老年代：</strong>存活率高，适合标记清理或整理。  </p>
</li>
<li><p><strong>Serial:</strong> 复制算法 单线程 client模式默认新生代收集器，stop the world,简单高效<br><strong>ParNew:</strong>  Serial的多线程版本，其他都 server模式首选，只有它能跟CMS搭配<br><strong>Parallel Scavenge:</strong> 关注吞吐量(cpu执行用户)</p>
<ul>
<li><p><strong>并行:</strong> 多个收集线程同时收集</p>
<p><strong>并发:</strong>收集线程和用户线程同时，不一定并行可能交替</p>
</li>
<li><p><strong>方法区(hotspot的永久代) 也可以回收</strong><br><strong>废弃常量</strong>的回收<br><strong>类的回收</strong>: 无对象，classloader已回收，该类对应的class文件没有被引用，且不可通过反射获取该方法</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-_TTL：">16. TTL：</h3><ul>
<li>Time To Live，指定IP包被路由器丢弃之前允许通过的最大网段数量。《TCP/IP详解卷I》路由器会丢弃ttl为0或1的数据包</li>
</ul>
<h3 id="17-_string类_能否继承？如果写一个类_不能被继承_final外_还有什么方法">17. string类 能否继承？如果写一个类 不能被继承  final外 还有什么方法</h3><ul>
<li>不能，因为是final的。  </li>
</ul>
<ul>
<li>还可以把构造函数私有化，单例模式</li>
</ul>
<h3 id="18-_链表的倒转，不倒转可以递归">18. 链表的倒转，不倒转可以递归</h3><h3 id="19-_session和cookie的区别：">19. session和cookie的区别：</h3><ul>
<li><p>session放在服务器，cookie放在客户端 </p>
</li>
<li><p>session不区分路径，在同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。也就是说，同一个用户的cookie，他换了浏览器，就访问不到之前的那个不同牌子的浏览器的cookie了。</p>
</li>
<li><p>session中保存的是对象，cookie中保存的是字符串。 </p>
</li>
<li><p>由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择【经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段】。</p>
</li>
</ul>
<h3 id="20-_单例模式线程安全">20.  单例模式线程安全</h3><ul>
<li>静态变量new 对象，类加载时即生成，</li>
<li>加锁：双重检测加锁 不能达到真正的线程安全，1.5之前主要是JIT编译器执行顺序问题.1.6之后可能是指令重排（volatile可解决？）</li>
<li><p>使用私有的静态类来实现：  </p>
<p>   public class Singleton<br>   {  </p>
<pre><code>private<span class="keyword"> static</span> class SingletonHolder //私有静态类  
{  
   <span class="keyword"> public</span><span class="keyword"> final</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;  
}  <span class="keyword">
public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>  
    {  
<span class="instruction"> return </span>SingletonHolder.instance;  
    }  
}
</code></pre></li>
</ul>
<ol>
<li>枚举单例</li>
</ol>
<h3 id="21-_序列化接口">21. 序列化接口</h3><ul>
<li>对象持久化，transient：修饰变量，不序列化 </li>
</ul>
<h3 id="22-_删除无头链表的某节点(编程之美3-4)">22. 删除无头链表的某节点(编程之美3.4)</h3><ul>
<li>将下一节点数据复制到该节点，删除下一节点而非该节点</li>
</ul>
<h3 id="23-_JAVA多态">23. JAVA多态</h3><ul>
<li>动态绑定(后期绑定，运行时绑定，前期是编译时绑定)</li>
</ul>
<ol>
<li>指向之类对象的指针，调用子类对象的方法(如果已重写父类方法，否则默认调父类方法)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_Finally，final，finalize">1. Finally，final，finalize</h3><ul>
<li><p>Finally：<br>  释放资源（内存之外的，打开的文件、连接、屏幕上的图形，，）</p>
<ul>
<li>总会执行</li>
<li>非后台线程结束，后台线程被强关，不会执行finally</li>
<li>当try和catch中有return时，finally在return之后执行，但是返回值不会改变（finally中不会改变已保存的返回结果）</li>
<li>finally中最好不要包含return，否则程序会从finally中退出，返回值不是try或catch中保存的返回值。</li>
</ul>
</li>
<li><p>final：<br>  基本数据类型：不可更改<br>  类：不可继承<br>  对象：引用不可变，对象内容可变</p>
</li>
<li><p>finalze：<br>回收前调用，不适合用来清理或释放资源。对象免死最后机会！保证会被调用，但不保证会执行完(在低优先级线程中执行)</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://zyq001.github.io/tags/Java/"/>
    
      <category term="面试" scheme="http://zyq001.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://zyq001.github.io/categories/Java/"/>
    
      <category term="面试" scheme="http://zyq001.github.io/categories/Java/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDN笔记]]></title>
    <link href="http://zyq001.github.io/2015/04/15/SDN%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyq001.github.io/2015/04/15/SDN笔记/</id>
    <published>2015-04-15T03:46:58.000Z</published>
    <updated>2015-09-03T15:11:03.296Z</updated>
    <content type="html"><![CDATA[<p>命令：<br>     <code>virsh net-list</code>  查看网桥</p>
<p>札记：<br>ovs超过1.9 无法配合kvm libirt<br>ubuntu 14.04 apt-cache ovs默认版本2.02<br>ubuntu server 制作简单U盘系统版不可用 </p>
<p>ovs-brcompatd is not running ？<br>安装ubuntu server<br><a id="more"></a><br>ubuntu server 安装<br>（事先把最后一个盘后面腾出空闲空间 ）<br>向导 使用最大连续空闲</p>
<p>网页 乱码<br>apt-get install xfonts-wqy<br> 中文支持</p>
<p>samba共享文件夹 只能共享一个 不能 共享多级</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>命令：<br>     <code>virsh net-list</code>  查看网桥</p>
<p>札记：<br>ovs超过1.9 无法配合kvm libirt<br>ubuntu 14.04 apt-cache ovs默认版本2.02<br>ubuntu server 制作简单U盘系统版不可用 </p>
<p>ovs-brcompatd is not running ？<br>安装ubuntu server<br>]]>
    
    </summary>
    
      <category term="SDN" scheme="http://zyq001.github.io/tags/SDN/"/>
    
      <category term="SDN" scheme="http://zyq001.github.io/categories/SDN/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【算法】求全排列 回溯 交换 DFS JAVA]]></title>
    <link href="http://zyq001.github.io/2015/04/15/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%B1%82%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%9E%E6%BA%AF-%E4%BA%A4%E6%8D%A2-DFS-JAVA/"/>
    <id>http://zyq001.github.io/2015/04/15/【算法】求全排列-回溯-交换-DFS-JAVA/</id>
    <published>2015-04-15T01:54:43.000Z</published>
    <updated>2015-09-03T15:17:50.401Z</updated>
    <content type="html"><![CDATA[<p>思路简述：<br>一个全排列其实就是一条把数组无重复遍历一遍的DFS过程<br>思路一：<strong>简单回溯</strong>，  </p>
<ol>
<li>一个List存遍历路径，从第N个“结点”到第N+1个“结点”是只需要找一个未遍历的结点就行  </li>
<li>一个关键点在于查找 下一个可遍历“结点”， 可以用SET辅助List存放已遍历结点，List中存遍历书序（文中方法未用SET，复杂度较高，但是可以在Leetcode上AC）；也可用一个数据结构完成：  LinkedHashMap，即可保存插入顺序，也可O(1)判断是否存在某元素。  </li>
<li>回溯： 选中某一子“结点”递归下去之后，要回溯查找另一“子节点”，这就是回溯的过程，通过把某时刻路径中最后结点删除，添加下一“子节点”实现  <a id="more"></a>
</li>
</ol>
<p>代码  </p>
<pre><code>public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permute(<span class="built_in">int</span>[] <span class="built_in">num</span>) {

    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt;();  
    <span class="keyword">if</span>(<span class="built_in">num</span> == <span class="keyword">null</span> || <span class="built_in">num</span>.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;  
    bt(res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>, <span class="built_in">num</span>);  
    <span class="keyword">return</span> res;  
}  

public <span class="keyword">void</span> bt(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">final</span> <span class="built_in">List</span>&lt;Integer&gt; cur, <span class="built_in">int</span> now, <span class="built_in">int</span>[] <span class="built_in">num</span>){
    <span class="built_in">int</span> length = <span class="built_in">num</span>.length;
    <span class="keyword">if</span>(cur.size() &gt;= length) {
        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(){
            {
                addAll(cur);
            }
        });
        <span class="keyword">return</span> ;
    }
    <span class="keyword">for</span>(<span class="built_in">int</span> i = now; i &lt; length || i % length &lt; now; i++){<span class="comment">//回溯</span>
        <span class="keyword">if</span>(cur.contains(<span class="built_in">num</span>[i % length])) <span class="keyword">continue</span>;<span class="comment">//判断回溯的元素是否已加入当前组合中</span>
        cur.add(<span class="built_in">num</span>[i % length]);
        bt(res, cur, (i  + <span class="number">1</span>)% length, <span class="built_in">num</span>);
        cur.remove(cur.size() - <span class="number">1</span>);
    }
}
</code></pre><p><strong>思路二：</strong><br> 基于思路一，<strong>不需要辅助List存放遍历路径</strong>，<strong>原数组就是遍历路径</strong><br>每次寻找下一遍历结点的过程可以转化为，<strong>将后一结点交换到当前结点</strong>的过程<br>还原交换的过程就是回溯的过程  </p>
<pre><code>public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permute(<span class="built_in">int</span>[] <span class="built_in">num</span>) {
    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt;();
    <span class="keyword">if</span>(<span class="built_in">num</span> == <span class="keyword">null</span> || <span class="built_in">num</span>.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;
    bt(res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>, <span class="built_in">num</span>);
    <span class="keyword">return</span> res;
}

public <span class="keyword">void</span> bt(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">final</span> <span class="built_in">List</span>&lt;Integer&gt; cur, <span class="built_in">int</span> now, <span class="keyword">final</span> <span class="built_in">int</span>[] <span class="built_in">num</span>){
    <span class="built_in">int</span> length = <span class="built_in">num</span>.length;
    <span class="keyword">if</span>(now &gt;= length) {
        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(){
            {
                <span class="keyword">for</span>(<span class="built_in">int</span> i: <span class="built_in">num</span>)
                add(i);
            }
        });
        <span class="keyword">return</span> ;
    }
    <span class="keyword">for</span>(<span class="built_in">int</span> i = now; i &lt; length; i++){
        swap(<span class="built_in">num</span>, now, i);
        bt(res, cur, now + <span class="number">1</span>, <span class="built_in">num</span>);
        swap(<span class="built_in">num</span>, now, i);
    }

}

public <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> idx1, <span class="built_in">int</span> idx2){
    <span class="built_in">int</span> temp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = temp;
}  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>思路简述：<br>一个全排列其实就是一条把数组无重复遍历一遍的DFS过程<br>思路一：<strong>简单回溯</strong>，  </p>
<ol>
<li>一个List存遍历路径，从第N个“结点”到第N+1个“结点”是只需要找一个未遍历的结点就行  </li>
<li>一个关键点在于查找 下一个可遍历“结点”， 可以用SET辅助List存放已遍历结点，List中存遍历书序（文中方法未用SET，复杂度较高，但是可以在Leetcode上AC）；也可用一个数据结构完成：  LinkedHashMap，即可保存插入顺序，也可O(1)判断是否存在某元素。  </li>
<li>回溯： 选中某一子“结点”递归下去之后，要回溯查找另一“子节点”，这就是回溯的过程，通过把某时刻路径中最后结点删除，添加下一“子节点”实现]]>
    
    </summary>
    
      <category term="算法， Java" scheme="http://zyq001.github.io/tags/%E7%AE%97%E6%B3%95%EF%BC%8C-Java/"/>
    
      <category term="算法" scheme="http://zyq001.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[笔记-数据库索引原理]]></title>
    <link href="http://zyq001.github.io/2015/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://zyq001.github.io/2015/03/15/数据库索引原理/</id>
    <published>2015-03-14T16:15:47.000Z</published>
    <updated>2015-09-02T17:08:12.382Z</updated>
    <content type="html"><![CDATA[<p>强烈建议参阅链接：<a href="http://www.linezing.com/blog/?p=798#nav-1" target="_blank" rel="external">http://www.linezing.com/blog/?p=798#nav-1</a></p>
<h2 id="索引问题就是一个查找问题。。。">索引问题就是一个<strong>查找问题</strong>。。。</h2><hr>
<p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用<strong>B树</strong>及其变种<strong>B+树</strong>。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br><img src="/images/index.png" alt="索引"><br>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。  </p>
<h3 id="创建索引可以大大提高系统的性能。">创建索引可以大大<strong>提高系统的性能</strong>。</h3><a id="more"></a>
<ul>
<li>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  </li>
</ul>
<ul>
<li>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。  </li>
</ul>
<ul>
<li>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。  </li>
</ul>
<ul>
<li>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。  </li>
</ul>
<ul>
<li>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。   </li>
</ul>
<p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多<strong>不利的方面</strong>:    </p>
<ul>
<li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。  </li>
</ul>
<ul>
<li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。  </li>
</ul>
<ul>
<li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h2 id="在哪建">在哪建</h2><p>–  </p>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在<strong>哪些列上可以创建索引</strong>，在<strong>哪些列上不能创建索引</strong>。  </p>
<h3 id="应该在这些列上创建索引：">应该在这些列上创建索引：</h3><ul>
<li>在经常需要<strong>搜索</strong>的列上，可以加快搜索的速度；  </li>
</ul>
<ul>
<li>在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；  </li>
</ul>
<ul>
<li>在经常用在<strong>连接</strong>的列上，这些列主要是一些<strong>外键</strong>，可以加快连接的速度；  </li>
</ul>
<ul>
<li>在经常需要根据<strong>范围</strong>进行搜索的列上创建索引，因为索引已经排序，其指定的范围是<strong>连续的</strong>；  </li>
</ul>
<ul>
<li>在经常<strong>需要排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；  </li>
</ul>
<ul>
<li>在经常使用在<strong>WHERE</strong>子句中的列上面创建索引，<strong>加快条件的判断速度</strong>。</li>
</ul>
<h3 id="不应该创建索引的的这些列具有下列特点："><strong>不应该创建索引</strong>的的这些列具有下列特点：</h3><ul>
<li>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。  </li>
</ul>
<ul>
<li>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。  </li>
</ul>
<ul>
<li>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。  </li>
</ul>
<ul>
<li>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。  </li>
</ul>
<h3 id="三种索引">三种索引</h3><p>根据数据库的功能，可以在数据库设计器中创建三种索引：<strong>唯一索引</strong>、<strong>主键索引</strong>和<strong>聚集索引</strong>。   </p>
<ul>
<li><strong>唯一索引</strong><br>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。  </li>
</ul>
<ul>
<li><strong>主键索引</strong>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。   </li>
</ul>
<ul>
<li><strong>聚集索引</strong>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。  如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</li>
</ul>
<h2 id="局部性原理与磁盘预读"><strong>局部性原理与磁盘预读</strong></h2><hr>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。<br>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。<br><strong>预读</strong>的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h2 id="B-/+Tree索引的性能分析"><strong>B-/+Tree索引的性能分析</strong></h2><hr>
<p>到这里终于可以分析B-/+Tree索引的性能了。<br>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。<br>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。<br>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。  </p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<h2 id="应该花时间学习B-树和B+树数据结构">应该花时间学习B-树和B+树数据结构</h2><p>1）<strong>B树</strong></p>
<p>B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。</p>
<p>成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。</p>
<p>在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。</p>
<p><strong>2）B+树</strong><br>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。</p>
<p>B+树有<strong>2个头指针</strong>，一个是树的<strong>根节点</strong>，一个是<strong>最小关键码的叶节点</strong>。</p>
<p>所以 B+树有两种搜索方法：</p>
<ul>
<li><p>一种是按叶节点自己拉起的链表顺序搜索。  </p>
</li>
<li><p>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</p>
</li>
</ul>
<p>B+ 树中，数据对象的<strong>插入</strong>和<strong>删除</strong>仅在<strong>叶节点</strong>上进行。</p>
<h3 id="这两种处理索引的数据结构的不同之处：">这两种处理索引的数据结构的不同之处：</h3><ul>
<li>a，B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。  </li>
</ul>
<ul>
<li>b，因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。  </li>
</ul>
<ul>
<li>c，B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</li>
</ul>
<p><strong>参考：</strong> <a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">http://blog.csdn.net/kennyrose/article/details/7532032</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>强烈建议参阅链接：<a href="http://www.linezing.com/blog/?p=798#nav-1">http://www.linezing.com/blog/?p=798#nav-1</a></p>
<h2 id="索引问题就是一个查找问题。。。">索引问题就是一个<strong>查找问题</strong>。。。</h2><hr>
<p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用<strong>B树</strong>及其变种<strong>B+树</strong>。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br><img src="/images/index.png" alt="索引"><br>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。  </p>
<h3 id="创建索引可以大大提高系统的性能。">创建索引可以大大<strong>提高系统的性能</strong>。</h3>]]>
    
    </summary>
    
      <category term="数据库" scheme="http://zyq001.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="http://zyq001.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="数据库" scheme="http://zyq001.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 类加载机制学习]]></title>
    <link href="http://zyq001.github.io/2015/03/02/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zyq001.github.io/2015/03/02/Java-类加载机制学习/</id>
    <published>2015-03-02T15:43:31.000Z</published>
    <updated>2015-09-02T17:09:30.716Z</updated>
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制：">虚拟机类加载机制：</h1><p>&#8195;&#8195;<strong>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>&#8195;&#8195;Java语言里，类型的</strong>加载<strong>和</strong>连接<strong>过程是在</strong>程序运行**期间完成的。  </p>
<p>类的<strong>生命周期：</strong><br>　　<strong>加载</strong> loading<br>　　<strong>验证</strong> verification<br>　　<strong>准备</strong> preparation<br>　　<strong>解析</strong> resolution<br>　　<strong>初始化</strong> initialization<br>　　<strong>使用</strong> using<br>　　<strong>卸载</strong> unloading  </p>
<p>&#8195;&#8195;<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>初始化</strong>、<strong>卸载</strong>5个阶段顺序是确定的，按这个顺序“开始”的。<br>&#8194;&#8194;&#8194;&#8194;解析可能发生在初始化之后，为了支持动态绑定通常互相交叉地混合进行一个阶段执行的过程中调用、激活另一阶段。</p>
<h2 id="主动引用&amp;被动引用：">主动引用&amp;被动引用：</h2><hr>
<a id="more"></a>
<p>有且只有以下四种情况必须立即对类进行”<strong>初始化</strong>”(称为对一个类进行<strong>主动引用</strong>)：  </p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时(使用new实例化对象的时候、读取或设置一个类的静态字段、调用一个类的静态方法)。  </li>
</ul>
<ul>
<li>使用java.lang.reflet包的方法对类进行反射调用的时候。  </li>
</ul>
<ul>
<li>当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化。  </li>
</ul>
<ul>
<li>当虚拟机启动时，虚拟机会初始化主类(包含main方法的那个类)。  </li>
</ul>
<p><strong>被动引用：</strong>  </p>
<ul>
<li>通过<strong>子类引用父类</strong>的<strong>静态字段</strong>，不会导致子类初始化(对于静态字段，只有直接定义这个字段的类才会被初始化)。  </li>
</ul>
<ul>
<li><strong>通过数组定义类应用类：</strong>ClassA [] array=new ClassA[10]。触发了一个名为[LClassA的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发。<br>常量会在编译阶段存入调用类的常量池。  </li>
</ul>
<ul>
<li>编译器会<strong>为接口生成 ()构造器</strong>，用于初始化接口中定义的成员变量。一个接口在初始化时，并<strong>不</strong>要求其<strong>父类接口</strong>全部完成了初始化，只有在真正使用到父接口的时候才会初始化。  </li>
</ul>
<h2 id="加载">加载</h2><hr>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流。  </li>
</ul>
<ul>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li>
</ul>
<ul>
<li><p>在内存中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。<br>{<strong>反射:</strong>就是取得这个class对象(通过”包名+类名”.class)，进而获取所有变量和方法，或直接newInstance调用默认构造器new一个对象}  </p>
</li>
<li><p><strong>非数组类的加载</strong> 可以自定义加载器（重载一个类加载器的loadClass()方法）</p>
</li>
<li><p><strong>数组类：</strong> <strong>类本身不通过类加载器创建</strong>，有JVM直接创建；数组类的元素类型（去掉维数的类型）最终需要类加载器去创建  </p>
</li>
<li><strong>引用类型：</strong>递归采用类的加载    基本类型（如int[]）：JVM标记为与引导类加载器关联<br>  数组类可见性与其他组件类型一致，非引用类型数组类可见性默认为public</li>
</ul>
<p><strong>完成后：</strong>虚拟机外部的二进制字节流存于<strong>方法区</strong>；内存中实例化一个 java.lang.Class对象（未规范，hotspot存于方法去）</p>
<h2 id="验证">验证</h2><hr>
<p>工作量占相当大一部分。重要但不必要（对程序运行期没有影响，如果确信运行的全部代码包括第三方包中已反复使用验证，可用-Xverify:none关闭大部分验证）<br><strong>验证：</strong>确保Class文件的字节流中包含的信息<strong>符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。<br>虚拟机规范：如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.<strong>VerifyError</strong>异常或其子类异常。  </p>
<ol>
<li><p><strong>文件格式验证：</strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这个阶段的验证时给予字节流进行的，经过了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储所以后面的验证阶段都是给予方法区的存储结构进行的。<br>如：<strong>魔数</strong>0xCAFEBASE，版本号，常量池中是否有不被支持的类型</p>
</li>
<li><p><strong>元数据验证：</strong>对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。<br>如：是否有父类，父类是否final，类中字段，方法是否与父类矛盾（覆盖final字段，不合规则重载reload，即参数一致返回值不同）（这些问题编译就不会通过，感觉很多验证有点多余，，不知对否）</p>
</li>
<li><p><strong>字节码验证：</strong>进行数据流和控制流分析，确定语义合法合逻辑,对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。<br>如：保证操作数栈中数据类型与指令代码配合工作（操作栈防止int，使用时却按long加载入本地变量表）； 保证类型转换有效；保证跳转指令不会跳转到方法体外的字节指令上</p>
</li>
<li><p><strong>符号引用验证：</strong>发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，对常量池中的各种符号引用的信息进行匹配性的校验。<br>如：通过权限定名是否能找到对应类；符号引用中类、字段、方法的访问性是否可悲当前类访问  </p>
</li>
</ol>
<h2 id="准备">准备</h2><hr>
<p>准备阶段是正式为<strong>类变量分配内存</strong>并设置<strong>类变量初始值</strong>(各数据类型的零值)的阶段，这些内存将在<strong>方法区</strong>中进行分配。但是如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会初始化为ConstantValue属性指定的值。<br><code>public static final int value=122;</code>（final：编译器已放入调用类的常量池；无final，则value为0，初始化时才赋值）  </p>
<h2 id="解析">解析</h2><hr>
<p>解析阶段是在虚拟机将<strong>常量池</strong>内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。<br><strong>符号引用：</strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并<strong>不一定已经加载到内存</strong>中。<br><strong>直接引用：</strong>直接引用可以是直接指向目标的<strong>指针</strong>、<strong>相对偏移量</strong>或者一个能间接定位到目标的<strong>句柄</strong>。如果有了直接引用，那引用的目标必定<strong>已经在内存</strong>中存在。  </p>
<ol>
<li><p><strong>类或接口</strong>(对应于常量池的CONSTANT_Class_info类型)的解析：<br>假设当前代码所处的类为D，需要将一个从未解析过的符号引用N解析为一个类或接口C的直接引用：<br>如果C不是一个数组类型，虚拟机将会把代表C的全限定名传递给D的类加载器去加载这个类。<br>如果C是一个数组类型，并且数组的元素类型为对象(N的描述符类似[Ljava.lang.Integer)，将会加载数组元素类型(java.lang.Integer)，接着由虚拟机生成一个代表此数组维度和元素的数组对象。<br>如果以上过程没有发生异常，则C在虚拟机中已经成为了一个有效的类和接口了，之后还要进行的是符号引用验证，确认D是否具有对C的访问权限，如果没有，将抛出java.lang.<strong>IllegalAccessError</strong>异常。</p>
</li>
<li><p><strong>字段</strong>(对应于常量池的CONSTANT_Fieldref_info类型)解析：<br>对字段表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个字段所属的类或接口。<br>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，如果C实现了接口，则会按照继承关系从下往上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，如果C不是java.lang.Object类型的话，将会按照继承关系从下往上递归的搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。否则，查找失败，抛出java.lang.NoSuchFieldError异常。<br>虚拟机的编译器实现可能会更严格：如果一个同名字段同时出现在C实现的接口和父类中，或者同时在自己或父类的多个接口中出现，编译器将可能拒绝编译。  </p>
</li>
</ol>
<ol>
<li><strong>类方法</strong>(对应于常量池的CONSTANT_Methodref_info类型)解析：<br>对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。<br>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，则抛出java.lang.IncompatibleClassChangeError。<br>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在C实现的接口列表及它们的父接口中递归的查找是否有简单名称和描述符都与目标相匹配的方法，如果有说明C是个抽象类，查找结束，抛出java.lang.AbstractMethodError异常。<br>否则，查找失败，抛出java.lang.NoSuchMethodError异常。<br>如果查找返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对这个方法的访问权限，则抛出java.lang.IllegalAccessError异常。  </li>
</ol>
<ol>
<li><strong>接口方法</strong>(对应于常量池的CONSTANT_InterfaceMethodref_info类型)：<br>对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。<br>如果在接口方法表中发现class_index中索引的C是个类，则抛出java.lang.IncompatibleClassChangeError。否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，在接口C的父接口中递归查找，知道java.lang.Object类(包括在内)，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。否则，查找失败，抛出java.lang.NoSuchMethodError。  </li>
</ol>
<h2 id="初始化">初始化</h2><hr>
<p>初始化阶段是<strong>执行类构造器</strong><clinit> ()方法的过程。  </clinit></p>
<ol>
<li>()方法是由编译器自动收集类中的 所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。<br>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。  </li>
</ol>
<ol>
<li>方法与实例构造器 ()不同，不需要显示的调用父类构造器，虚拟机会保证在子类的 ()方法执行之前，父类的 ()已经执行完毕。</li>
</ol>
<ol>
<li>()方法对于类或接口来说不是必须的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成 ()方法。</li>
</ol>
<ol>
<li>执行接口的 ()不需要先执行父接口的 ()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。 接口的实现类在初始化时也不会执行接口的 ()方法 。</li>
</ol>
<ol>
<li>虚拟机会保证一个类的 ()方法在多线程环境中被正确的加锁和同步，如果多个线程同时去初始化一个类，则只会有一个线程去执行这个类的               ()方法，其他线程需要阻塞等待 。</li>
</ol>
<h1 id="类加载器">类加载器</h1><hr>
<p>都有<strong>独立的类名称空间</strong>：比较两个类是否相等 前提是由同一个类加载器加载；否则，即使同一个class文件，相同虚拟机加载，但类加载器不同，这两个类必定不同。  </p>
<h3 id="双亲委派模型：（规范推荐，非强制）">双亲委派模型：（规范推荐，非强制）</h3><p><img src="/images/JvmLoad/classLoader.jpeg" alt="ClassLoader"><br><strong>启动类加载器</strong>（Bootstrap ClassLoader）&lt;–<strong>扩展类加载器</strong>（Extension ClassLoader）&lt;–<strong>应用程序</strong><br>先传给父类加载器，父类加载器无法加载，子类加载器才会尝试加载。保证基础类被同一个加载器加载；如java.lang.Object永远会被Bootstrap ClassLoader加载</p>
<p>新建一个rt.jar中重名的类，编译成功，但永远无法被加载，即使使用自定义类加载器强行加载也不行，还会抛异常SecurityException<br><strong>被破坏：</strong>OSGi：平级搜索类加载器</p>
<h3 id="对象创建：">对象创建：</h3><p>类加载-开内存-引用入栈本地变量表（及当前调用new对象的方法的本地变量表）<br>引用reference：①存句柄地址 句柄包含具体对象实例数据和类型数据地址信息；优点：稳定的引用地址，对象被移动只需改变句柄里的地址，缺点：多一次指针定位的开销<br>②直接指针：存对象地址 快  HotSpot采用</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="虚拟机类加载机制：">虚拟机类加载机制：</h1><p>&#8195;&#8195;<strong>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>&#8195;&#8195;Java语言里，类型的</strong>加载<strong>和</strong>连接<strong>过程是在</strong>程序运行**期间完成的。  </p>
<p>类的<strong>生命周期：</strong><br>　　<strong>加载</strong> loading<br>　　<strong>验证</strong> verification<br>　　<strong>准备</strong> preparation<br>　　<strong>解析</strong> resolution<br>　　<strong>初始化</strong> initialization<br>　　<strong>使用</strong> using<br>　　<strong>卸载</strong> unloading  </p>
<p>&#8195;&#8195;<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>初始化</strong>、<strong>卸载</strong>5个阶段顺序是确定的，按这个顺序“开始”的。<br>&#8194;&#8194;&#8194;&#8194;解析可能发生在初始化之后，为了支持动态绑定通常互相交叉地混合进行一个阶段执行的过程中调用、激活另一阶段。</p>
<h2 id="主动引用&amp;被动引用：">主动引用&amp;被动引用：</h2><hr>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://zyq001.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://zyq001.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://zyq001.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[svn常用概念总结]]></title>
    <link href="http://zyq001.github.io/2014/09/03/svn%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://zyq001.github.io/2014/09/03/svn常用概念总结/</id>
    <published>2014-09-03T01:55:40.000Z</published>
    <updated>2015-09-03T02:42:12.002Z</updated>
    <content type="html"><![CDATA[<p>原理是这样的 svn服务器一般放在公共的服务器上，大家连这个服务器，在Eclipse上使用svn控件 可以下载svn上的项目至本地，所以很多公司将开发要用到的软件都放在svn上，有同事来只要连上svn 就可以把需要的东西下下来了</p>
<ul>
<li><strong>更新</strong>是指 服务器上变动了的 而你本地没有变动，需要你更新， update更新</li>
</ul>
<ul>
<li><strong>提交</strong>是指 服务器上没有的，也就是你改过的东西，你需要将代码提交，其他同事更新你的代码 commit 提交</li>
</ul>
<p>同步，是在更新提交之前做的工作，更新提交前先同步，可以知道哪些东西要提交哪些东西要更新，哪些东西是冲突的（你和同事 改了同一个文件，可能会出现冲突），出现冲突不能提交也不能更新，只有先将冲突的文件选择用本地的文件覆盖或用服务器的文件覆盖本地后才能更新或提交，具体的用法还需要楼主多实践，这东西用过一次就会了 上面术语在MyEclipse里的选项是  </p>
<ol>
<li><strong>同步：</strong>synchronize with repository (如果你的项目连了svn 右键你的项目 team…就能看到) 点击同步后会进入到synchronize 的界面 再右键项目就有  </li>
</ol>
<ol>
<li><strong>Mark as mergerd</strong> （冲突时点它 冲突的文件会用本地的覆盖服务器的，意思就是说 用你的！）   </li>
<li><strong>override and update</strong> (冲突时 右键文件 选此项表示 用服务器的！)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原理是这样的 svn服务器一般放在公共的服务器上，大家连这个服务器，在Eclipse上使用svn控件 可以下载svn上的项目至本地，所以很多公司将开发要用到的软件都放在svn上，有同事来只要连上svn 就可以把需要的东西下下来了</p>
<ul>
<li><strong>更]]>
    </summary>
    
      <category term="svn" scheme="http://zyq001.github.io/tags/svn/"/>
    
      <category term="研发管理" scheme="http://zyq001.github.io/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
      <category term="研发管理" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
      <category term="svn" scheme="http://zyq001.github.io/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/svn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux(CentOS) Wget安装配置 [用户] Oracle JDK]]></title>
    <link href="http://zyq001.github.io/2014/08/15/Linux-CentOS-Wget%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7Oracle-JDK/"/>
    <id>http://zyq001.github.io/2014/08/15/Linux-CentOS-Wget安装配置用户Oracle-JDK/</id>
    <published>2014-08-15T01:55:56.000Z</published>
    <updated>2015-09-03T02:33:57.003Z</updated>
    <content type="html"><![CDATA[<p>背景：<br>开发机上的系统JDK是1.6的，由于项目需要1.7，故决定下载一个jdk7，并配置到用户环境变量中；<br>尝试直接用wget从官网上下，结果下来都是一个几k的文件，应该是oracle上的防盗链，也就是用图形界面要先点accept；<br>用本地Windows下载好之后通过rz传上去，结果最近网络有点问题，很慢，还经常一半停下来，，</p>
<p>网上搜了一下<br>  基于wget重定向，可以带一些cookie欺骗orcle，<br>  一般都说的加上  </p>
<p>  <code>--no-cookie --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F&quot;</code><br><a id="more"></a><br>如果出现Unable to establish SSL connection的话，在wget后面加上–no-check-certificate即可，即：  </p>
<p>  <code>wget --no-cookie --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F&quot;</code>  </p>
<p>而经过测试，起码在我们这边是行不通的，跟不加一样，<br>  后来看到这篇文章：<a href="https://ivan-site.com/2012/05/download-oracle-java-jre-jdk-using-a-script/解决问题。" target="_blank" rel="external">https://ivan-site.com/2012/05/download-oracle-java-jre-jdk-using-a-script/解决问题。</a><br>   完整命令为：  </p>
<pre><code>wget --<span class="keyword">no</span>-cookies --<span class="keyword">no</span>-check-certificate --header <span class="string">"Cookie: gpw_e24=http<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2Fwww</span>.oracle.com<span class="variable">%2F</span>; oraclelicense=accept-securebackup-cookie"</span> <span class="string">"http://download.oracle.com/otn-pub/java/jdk/7u4-b20/jdk-7u4-linux-x64.tar.gz"</span>  
</code></pre><p>下载完之后</p>
<pre><code>tar -zxvf *<span class="class">.tar</span><span class="class">.gz</span>
</code></pre><p>然后  </p>
<pre><code>vi ~/<span class="class">.profile</span>  
</code></pre><p>添加如下  </p>
<pre><code>export JAVA_HOME=/你的路径/jdk1.<span class="number">7.0_79</span>export CLASSPATH=<span class="variable">$JAVE</span>_HOME/lib/export PATH=<span class="variable">$JAVA</span>_HOME/bin/:<span class="variable">$PATH</span>  
</code></pre><p><strong>注意吧$JAVA_HOME/bin/写在前面，不然java -version还是先找到系统的java  </strong><br>然后<br>    <code>source ~/.profile</code>    </p>
<p>可以换成想要的版本，贴一些：<br>JDK 8u25</p>
<ul>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-i586.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-i586.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-x64.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-x64.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-macosx-x64.dmg" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-macosx-x64.dmg</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-sparcv9.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-sparcv9.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-x64.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-x64.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jdk-8u25-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jdk-8u25-windows-i586.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jdk-8u25-windows-i586.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jdk-8u25-windows-x64.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jdk-8u25-windows-x64.exe</a>  </li>
</ul>
<p>JDK 7u72</p>
<ul>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-i586.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-i586.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-x64.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-x64.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-macosx-x64.dmg" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-macosx-x64.dmg</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-i586.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-i586.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-x64.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-x64.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparc.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparc.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparc.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparc.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparcv9.tar.Z" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparcv9.tar.Z</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-windows-i586.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-windows-i586.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-windows-x64.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jdk-7u72-windows-x64.exe</a>  </li>
</ul>
<p>JRE 8u25</p>
<ul>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-i586.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-i586.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-x64.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-x64.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-macosx-x64.dmg" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-macosx-x64.dmg</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-macosx-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-macosx-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/jre-8u25-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586-iftw.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586-iftw.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-x64.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-x64.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/jre-8u25-windows-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b17/server-jre-8u25-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u25-b18/server-jre-8u25-windows-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/8u25-b18/server-jre-8u25-windows-x64.tar.gz</a>  </li>
</ul>
<p>JRE 7u72</p>
<ul>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-i586.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-i586.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-x64.rpm" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-x64.rpm</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-macosx-x64.dmg" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-macosx-x64.dmg</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-macosx-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-macosx-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-sparc.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-sparc.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586-iftw.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586-iftw.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-x64.exe" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-x64.exe</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/jre-7u72-windows-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-linux-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-i586.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-i586.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-sparc.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-sparc.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-sparcv9.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-sparcv9.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-solaris-x64.tar.gz</a></li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-windows-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u72-b14/server-jre-7u72-windows-x64.tar.gz</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>背景：<br>开发机上的系统JDK是1.6的，由于项目需要1.7，故决定下载一个jdk7，并配置到用户环境变量中；<br>尝试直接用wget从官网上下，结果下来都是一个几k的文件，应该是oracle上的防盗链，也就是用图形界面要先点accept；<br>用本地Windows下载好之后通过rz传上去，结果最近网络有点问题，很慢，还经常一半停下来，，</p>
<p>网上搜了一下<br>  基于wget重定向，可以带一些cookie欺骗orcle，<br>  一般都说的加上  </p>
<p>  <code>--no-cookie --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F&quot;</code><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://zyq001.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://zyq001.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 泛型参数 向上转型]]></title>
    <link href="http://zyq001.github.io/2014/06/03/Java-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
    <id>http://zyq001.github.io/2014/06/03/Java-泛型参数-向上转型/</id>
    <published>2014-06-03T01:54:27.000Z</published>
    <updated>2015-09-03T02:26:04.491Z</updated>
    <content type="html"><![CDATA[<p>根据现在的了解，java泛型默认是不支持向上转型的，但是可以通过<strong>泛型参数</strong>实现<strong>向上转型</strong></p>
<p><code>List&lt;List&lt;Integer&gt;&gt; re = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</code>//这样编译通过 类型不匹配，无法转型</p>
<p><code>List&lt;? extends List&lt;Integer&gt;&gt; re = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</code>//但是这样就可以，因为添加了泛型参数，任何继承List的类都没有问题</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据现在的了解，java泛型默认是不支持向上转型的，但是可以通过<strong>泛型参数</strong>实现<strong>向上转型</strong></p>
<p><code>List&lt;List&lt;Integer&gt;&gt; re = new ArrayL]]>
    </summary>
    
      <category term="Java" scheme="http://zyq001.github.io/tags/Java/"/>
    
      <category term="算法" scheme="http://zyq001.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
